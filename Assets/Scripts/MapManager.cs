using System.Collections.Generic;using UnityEngine;using UnityEngine.Serialization;using UnityEngine.Tilemaps;public class MapManager : MonoBehaviour{    public Tilemap tilemap;    public Transform player;    private Vector2 _chunkSize;    private int _loadRadius;    private Vector3Int _originalPlayerCell;    private BoundsInt _tilemapBounds;    private TileBase[] _initialTiles;    private HashSet<Vector3Int> _activeTileChunks = new();    private Camera _mainCamera;    void Start()    {        // 초기 타일맵 데이터를 저장        _tilemapBounds = tilemap.cellBounds;        _initialTiles = tilemap.GetTilesBlock(_tilemapBounds);        _chunkSize = new Vector2(_tilemapBounds.size.x, _tilemapBounds.size.y);                // 카메라 캐싱        _mainCamera = Camera.main;        CenterPlayerOnTilemap();        CalculateMapRadius();        GenerateTilesAroundPlayer(_originalPlayerCell);    }    void Update()    {        Vector3Int playerCell = tilemap.WorldToCell(player.position);        // 플레이어가 타일맵 가장자리 영역을 벗어나면 새로운 타일맵을 생성        if (HasPlayerMovedToNewChunk(playerCell))        {            _originalPlayerCell = playerCell;            GenerateTilesAroundPlayer(_originalPlayerCell);        }    }    private bool HasPlayerMovedToNewChunk(Vector3Int playerCell)    {        return Mathf.Abs(playerCell.x - _originalPlayerCell.x) >= _chunkSize.x / 2 ||               Mathf.Abs(playerCell.y - _originalPlayerCell.y) >= _chunkSize.y / 2;    }    private void CalculateMapRadius()    {        if (_mainCamera == null) return;        // 화면 가장자리에 보이는 지점과 플레어와의 거리 계산        Vector3 screenBottomLeft = _mainCamera.ViewportToWorldPoint(new Vector3(0, 0, _mainCamera.nearClipPlane));        Vector3 screenTopRight = _mainCamera.ViewportToWorldPoint(new Vector3(1, 1, _mainCamera.nearClipPlane));        float horizontalDistance = Mathf.Abs(screenTopRight.x - screenBottomLeft.x) / 2;        float verticalDistance = Mathf.Abs(screenTopRight.y - screenBottomLeft.y) / 2;        float radius = Mathf.Abs(Mathf.Sqrt(Mathf.Pow(horizontalDistance, 2) + Mathf.Pow(verticalDistance, 2)));        //반지름을 타일 뭉치의 크기로 나눔        _loadRadius = Mathf.CeilToInt(radius / _chunkSize.x) + 2;    }    private void CenterPlayerOnTilemap()    {        if (_mainCamera == null) return;        // 화면 중심 좌표        Vector3 screenCenterWorld = _mainCamera.ViewportToWorldPoint(new Vector3(0.5f, 0.5f, 0));        screenCenterWorld.z = 0;        // 화면 중심에 해당하는 타일맵 좌표 계산        Vector3Int centerCell = tilemap.WorldToCell(screenCenterWorld);        Vector3 centerWorldPosition = tilemap.CellToWorld(centerCell);        // 타일맵 중심과 플레이어 위치를 화면 중심으로 이동        tilemap.transform.position += screenCenterWorld - centerWorldPosition;        player.position = screenCenterWorld;        // 이동시킨 좌표를 초기 플레이어 좌표로 계산        _originalPlayerCell = tilemap.WorldToCell(player.position);    }    private void GenerateTilesAroundPlayer(Vector3Int centerCell)    {        // 맵 생성의 중심이 될 위치를 셀 크기에 맞게 재조정        centerCell.x = Mathf.FloorToInt(centerCell.x / _chunkSize.x) * (int)_chunkSize.x;        centerCell.y = Mathf.FloorToInt(centerCell.y / _chunkSize.y) * (int)_chunkSize.y;        // 재조정 된 중심 위치를 기준으로 타일맵 생성        for (int x = -_loadRadius; x <= _loadRadius; x++)        {            for (int y = -_loadRadius; y <= _loadRadius; y++)            {                Vector3Int offset = new Vector3Int(                    centerCell.x + x * (int)_chunkSize.x,                    centerCell.y + y * (int)_chunkSize.y,                    0                );                // 이미 생성된 위치는 스킵                if (_activeTileChunks.Contains(offset)) continue;                PlaceTiles(offset);                _activeTileChunks.Add(offset);            }        }    }    private void PlaceTiles(Vector3Int offset)    {        for (int x = 0; x < _tilemapBounds.size.x; x++)        {            for (int y = 0; y < _tilemapBounds.size.y; y++)            {                Vector3Int oldPos = new Vector3Int(_tilemapBounds.xMin + x, _tilemapBounds.yMin + y, 0);                TileBase tile = _initialTiles[x + y * _tilemapBounds.size.x];                if (tile is not null)                {                    Vector3Int newPos = oldPos + offset;                    tilemap.SetTile(newPos, tile);                    // 기존 타일맵의 scale 유지                    Matrix4x4 matrix = tilemap.GetTransformMatrix(oldPos);                    tilemap.SetTransformMatrix(newPos, matrix);                }            }        }    }}